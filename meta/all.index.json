{
  "ownKey": "index",
  "childrenPages": {"changelog": {
    "ownKey": "changelog",
    "ownPages": [{
      "reference": {
        "path": "",
        "baseUrl": "https://copper-leaf.github.io/kudzu",
        "fileName": "changelog",
        "extension": "html",
        "usePrettyUrl": true,
        "link": "https://copper-leaf.github.io/kudzu/changelog"
      },
      "description": "",
      "title": "Changelog",
      "content": ""
    }]
  }},
  "ownPages": [
    {
      "reference": {
        "path": "",
        "baseUrl": "https://copper-leaf.github.io/kudzu",
        "fileName": "",
        "extension": "html",
        "usePrettyUrl": true,
        "link": "https://copper-leaf.github.io/kudzu"
      },
      "description": "",
      "title": "Home",
      "content": "<h1 id=\"kudzu\"><a href=\"#kudzu\" id=\"kudzu\" class=\"anchor\"><\/a>Kudzu<\/h1>\n<hr />\n<blockquote>\n<p>A monadic (I think...) recursive-descent parser combinator written in Kotlin<\/p>\n<\/blockquote>\n<p><img src=\"https://img.shields.io/github/v/release/copper-leaf/kudzu\" alt=\"GitHub release (latest by date)\" />\n<img src=\"https://img.shields.io/maven-central/v/io.github.copper-leaf/kudzu-core\" alt=\"Maven Central\" />\n<img src=\"https://img.shields.io/badge/Kotlin-1.8.20-orange\" alt=\"Kotlin Version\" /><\/p>\n<p>Kudzu is a recursive-descent parser written in Kotlin, inspired by <a href=\"https://github.com/haskell/parsec\">Parsec<\/a>, with the\ngoal of immutability, simplicity, testability, and multiplatform usability. It's designed to be a simple starting place\nfor writing smaller parsers to evaluate relatively simple grammars for other Copper-Leaf libraries, but flexible enough\nto be used for larger languages.<\/p>\n<h2 id=\"installation\"><a href=\"#installation\" id=\"installation\" class=\"anchor\"><\/a>Installation<\/h2>\n<pre><code class=\"language-kotlin\">repositories {\n    mavenCentral()\n}\n\n// for plain JVM or Android projects\ndependencies {\n    implementation(&quot;io.github.copper-leaf:kudzu-core:5.3.0&quot;)\n}\n\n// for multiplatform projects\nkotlin {\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                implementation(&quot;io.github.copper-leaf:kudzu-core:5.3.0&quot;)\n            }\n        }\n    }\n}\n<\/code><\/pre>\n<h2 id=\"basic-usage\"><a href=\"#basic-usage\" id=\"basic-usage\" class=\"anchor\"><\/a>Basic Usage<\/h2>\n<p>See tests for example usage of every included parser. A basic example of parsing and evaluating in several different\nformats follows:<\/p>\n<h3 id=\"combine-several-small-parsers-into-a-single-larger-one\"><a href=\"#combine-several-small-parsers-into-a-single-larger-one\" id=\"combine-several-small-parsers-into-a-single-larger-one\" class=\"anchor\"><\/a>Combine several small parsers into a single larger one<\/h3>\n<pre><code class=\"language-kotlin\">val intLiteralParser = MappedParser(\n    SequenceParser(\n        MaybeParser(\n            CharInParser('-')\n        ),\n        AtLeastParser(\n            DigitParser(),\n            minSize = 1\n        )\n    )\n) { it.text.toInt() }\n\nval (node, remainingText) = intLiteralParser.parse(ParserContext.fromString(&quot;-123&quot;))\nval parsedValue: Int = node.value\nexpectThat(parsedValue).isEqualTo(-123)\n<\/code><\/pre>\n<h3 id=\"find-and-replace-structured-sequences-within-unstructured-text\"><a href=\"#find-and-replace-structured-sequences-within-unstructured-text\" id=\"find-and-replace-structured-sequences-within-unstructured-text\" class=\"anchor\"><\/a>Find-and-replace structured sequences within unstructured text<\/h3>\n<pre><code class=\"language-kotlin\">val variableMap = mapOf(\n    &quot;asdf&quot; to 1,\n    &quot;qwerty&quot; to 2,\n)\n\nval patternToReplace = MappedParser(\n    SequenceParser(\n        CharInParser('#'),\n        CharInParser('{'),\n        IdentifierTokenParser(),\n        CharInParser('}'),\n    )\n) {\n    val (_, _, identifier, _) = it.children\n    variableMap[identifier.text]\n}\n\nval findAndReplaceParser = ManyParser(\n    PredictiveChoiceParser(\n        patternToReplace,\n        ScanParser(patternToReplace),\n    )\n)\n\nval (node, remainingText) = findAndReplaceParser.parse(ParserContext.fromString(&quot;the value of #{asdf} is 1, but #{qwerty} is 2&quot;))\nexpectThat(node.text).isEqualTo(&quot;the value of 1 is 1, but 2 is 2&quot;)\n<\/code><\/pre>\n<h3 id=\"construct-and-evaluate-expressions-with-custom-operators\"><a href=\"#construct-and-evaluate-expressions-with-custom-operators\" id=\"construct-and-evaluate-expressions-with-custom-operators\" class=\"anchor\"><\/a>Construct and evaluate expressions with custom operators<\/h3>\n<pre><code class=\"language-kotlin\">val expressionParser = ExpressionParser&lt;Int&gt;(\n    termParser = { IntLiteralParser() },\n\n    Operator.Infix(op = &quot;+&quot;, 40) { l, r -&gt; l + r },\n    Operator.Infix(op = &quot;-&quot;, 40) { l, r -&gt; l - r },\n    Operator.Infix(op = &quot;*&quot;, 60) { l, r -&gt; l * r },\n    Operator.Infix(op = &quot;/&quot;, 60) { l, r -&gt; l / r },\n\n    Operator.Prefix(op = &quot;-&quot;, 80) { r -&gt; -r },\n    Operator.Infixr(op = &quot;^&quot;, 70) { l, r -&gt; l.toDouble().pow(r).toInt() },\n)\n\nval (node, remainingText) = expressionParser.parse(ParserContext.fromString(&quot;2 ^ ((4 - 2) * 2)&quot;, skipWhitespace = true))\nval value = expressionParser.evaluator.evaluate(node)\nexpectThat(value).isEqualTo(16)\n<\/code><\/pre>\n<h2 id=\"implementation-details\"><a href=\"#implementation-details\" id=\"implementation-details\" class=\"anchor\"><\/a>Implementation Details<\/h2>\n<p>In Kudzu, a Parser is a class that extends <code>Parser<\/code> and implements 2 methods: <code>predict<\/code>, and <code>parse<\/code>. <code>predict<\/code> is a\nmethod that checks if the parser is capable of consuming the next character, and <code>parse<\/code> actually implements the parsing\nlogic, and returns a <code>Node<\/code>.<\/p>\n<p>There are 2 types of nodes, <code>TerminalNode<\/code> and <code>NonTerminalNode<\/code>. A <code>TerminalNode<\/code> typically holds onto the raw text\nthat was parsed from the input, while a <code>NonTerminalNode<\/code> holds onto other nodes. In this manner, non-terminal nodes\ncomprise the inner nodes of the parse tree, while terminal nodes comprise the leaves of the parse tree.<\/p>\n<p>Unlike some other parsing libraries, Kudzu does not impose any restrictions on the type of node that a parser produces\nto keep type parameters to a minimum and code readability to a maximum. Instead of evaluating a parse tree by working\nwith specific subclasses, evaluation is done simply by knowledge of whether a node is a terminal or non-terminal node,\nand the name of the node. There are APIs to aid in navigating the parse tree and finding specific nodes based on their\ntype or their name.<\/p>\n<p>The APIs are designed that each step is kept very isolated, so that the code for one step can be easily swapped out or\nreused as-needed, allowing great flexibility, while keeping the code for each phase clean and easy to understand. The\ngeneral process of parsing and evaluating text with Kudzu is as follows:<\/p>\n<pre><code>1) String\n2) ParserContext\n3) Parser.parse(ParserContext) -&gt; Pair&lt;Node, ParserContext&gt;\n4) Node.visit([Visitor]) -&gt; Unit\n<\/code><\/pre>\n<ol>\n<li>The String text that is to be parsed.<\/li>\n<li>Provides sole API for parsers to consume individual characters. Tracks source position.<\/li>\n<li>Each grammar has a single root rule, which is defined as a simple instance of <code>Parser<\/code>. The result is a single root\nNode and a ParserContext representing the text that remains unconsumed. A successful parse is expected to return an\nempty ParserContext. This root parser will recursively call the same method on other parser objects, each one\nbuilding more nodes in the full tree and advancing the position in the ParserContext.<\/li>\n<li>The Node can be visited by any number of Visitor objects, which recognize and evaluate distinct nodes in the parse\ntree.<\/li>\n<\/ol>\n<h3 id=\"building-parsers\"><a href=\"#building-parsers\" id=\"building-parsers\" class=\"anchor\"><\/a>Building Parsers<\/h3>\n<p>While you can create custom Parser subclasses which implement your parsing logic, it is typically better to use the\nbuilt-in parser primitives provided by Kudzu. A basic example of building a Parser which recognizes either a full word\nor a number follows:<\/p>\n<pre><code class=\"language-kotlin\">val wordParser = ManyParser(LetterParser())\nval numberParser = ManyParser(DigitParser())\nval tokenParser = PredictiveChoiceParser(\n        wordParser, \n        numberParser\n)\nval statement = ManyParser(\n    SequenceParser(\n        tokenParser, \n        OptionalWhitespaceParser()\n    )\n)\n\nval output = statement.parse(ParserContext.fromString(&quot;one two 1234 asdf 56 qwerty 7890&quot;))\n<\/code><\/pre>\n<p>This simple grammar will match an input string like <code>one two 1234 asdf 56 qwerty 7890<\/code>, and demonstrates how complex\nparsers can be built from smaller ones, and introduces several of the important built-in parses available. Below is a\ndescription of some of these parser types (browse source for all available parsers)<\/p>\n<ul>\n<li><code>LetterParser<\/code>: Consumes a single letter from the input, as recognized by Kotlin's <code>char.isLetter()<\/code><\/li>\n<li><code>DigitParser<\/code>: Consumes a single digit from the input, as recognized by Kotlin's <code>char.isDigit()<\/code><\/li>\n<li><code>ManyParser<\/code>: Takes another Parser and repeatedly consumed input from that parser, for as long as that parser is able\nto. Since it is itself a <code>Parser<\/code>, and it takes a <code>Parser<\/code> as an input, the full grammar is now recursively-defined,\nand uses a predictive* approach to determining if the next iteration of its parser can continue. You can pass any\nother Parser to this, not just character-type parsers, and so arbitrarily-complex sub-grammars can be repeated as\nneeded. You'll notice that we gave the parser a <code>name<\/code>. This name is attached to the nodes it produces, so that when\nwe evaluate the parse tree, we can look for nodes named <code>word<\/code> or <code>number<\/code>, and take different actions accordingly.<\/li>\n<li><code>PredictiveChoiceParser<\/code>: Takes a list of sub-parsers, and predicatively* picks one to continue parsing with.<\/li>\n<li><code>SequenceParser<\/code>: Takes a list of sub-parsers, and executes each one a single time in order.<\/li>\n<li><code>OptionalWhitespaceParser<\/code>: Consumes and throws away whitespace if it exists. As the whitespace is optional, and input\nsuch as <code>two1234<\/code> would still match and be parsed correctly.<\/li>\n<li><code>LazyParser<\/code>: Some grammars have production rules that themselves are recursive, such as <code>A := B A<\/code>. The <code>LazyParser<\/code>\nacts as a placeholder, simply delegating to another parser. The recursive rules must be built using these lazy\ntypes, since we need a concrete instance to pass to another parsers. This lazy parser allows us to create the parser\nreference, passing it around to the parsers that need it, and at a later point fill in the details of the parser as\nneeded.<\/li>\n<\/ul>\n<ul>\n<li>A predictive grammar tests if the parser can be used by first calling its <code>predict<\/code> method. This method is expected to\ncheck if it is able to consume the next character, and if it cannot consume the next character, then the entire parser\ncannot continue. For <code>many<\/code>-type parsers, this predictability is used to determine when to stop iterating. For\n<code>choice<\/code>-type parsers, this determines which sub-production is chosen: the first sub-parser for which <code>predict<\/code> returns\ntrue will be used, and other rules will not be tested. This is to improve performance and prevent infinite recursion.<\/li>\n<\/ul>\n<h3 id=\"evaluating-parse-trees\"><a href=\"#evaluating-parse-trees\" id=\"evaluating-parse-trees\" class=\"anchor\"><\/a>Evaluating Parse Trees<\/h3>\n<p>Once the full parser has been built, and text parsed into an AST, we can now evaluate it. Evaluating an AST consists of\na <code>Visitor.Callback<\/code>, or a simple lambda callback. A basic example, using a fictional grammar, follows:<\/p>\n<pre><code class=\"language-kotlin\">val parser = constructParser()\n\nval (node, _) = parser.parse(input)\n\n// simple visiting, such as finding all nodes of a particular type and not caring about the structure\nnode.visit { node -&gt; \n    // do something with each node as it is entered in the tree\n}\n\n// alternatively, visit with a full set of callbacks to also introspect the parse-tree's structure\nnode.visit(object : Visitor.Callback {\n    var depth: Int = 0\n    override fun enter(node: Node) {\n        depth++\n    }\n    override fun exit(node: Node) {\n        depth--\n    }\n    override fun onStart() { }\n    override fun onFinish() { }\n})\n<\/code><\/pre>\n"
    },
    {
      "reference": {
        "path": "",
        "baseUrl": "https://copper-leaf.github.io/kudzu",
        "fileName": "404",
        "extension": "html",
        "usePrettyUrl": false,
        "link": "https://copper-leaf.github.io/kudzu/404.html"
      },
      "description": "",
      "title": "Not Found",
      "content": ""
    }
  ]
}